
# IO设备的数据传送方式

---
## CPU与IO设备间的接口信息
### 数据
**数据**是CPU与I/O设备传送的主体

位数：
* 8位
* 16位
* 32位

类型：
* 数字量
    * 以二进制形式表示的数据或以ASCII码表示的字符
* 模拟量
    * 现场信息
* 开关量
    * 只有两种状态的量

### 状态信息
反映外设当前工作状态
* 输入：输入设备是否准备好
* 输出：输出设备是否空闲

### 控制信息
控制输入输出装置启动或停止

### 数据交换方式
* 程序直接控制
* 程序中断
* 直接存储器访问（DMA）
* 通道传输（IOP）

---
## IO端口与端口地址
**接口**：将外部设备与大容量存储设备连接到系统上
**IO端口**：接口内寄存器地址分配的唯一一个地址编码

### 寄存器
* 数据寄存器
    * 数据缓冲
* 状态寄存器
    * 保存设备和接口的状态信息，供CPU对外设调试
* 命令寄存器
    * 保存CPU发出的命令以控制接口和设备

### IO端口地址编址
* 将IO与内存单元统一编址
    * 节省了IO指令，但是占用了内存单元
* IO独立编址
    * IO端口编址在独立的地址空间
    * 80x86中设置有64k个8位端口或32k和16位端口

---
## IO指令
### 寻址方式
* 存储器对应输入输出
    * 一个外设接口作为存储器的一个单元
    * 一个外设占用存储器的一个地址
    * 优点：
        * 指令多，使用方便
        * 内存和外设的地址分布图相同
        * 不需要专门的IO指令
    * 缺点：
        * 占用了内存空间，内存容量减少
        * 寻址的外设端口地址比外设单元少很多
* 端口寻址的输入输出
    * CPU有专门的IO指令，用地址来区分不同的外设

### 输入输出指令
IO指令是CPU与外部设备通信的最基本途径  
即便调用DOS功能调用/BIOS中断，其中断程序本身也是通过IN和OUT指令与外设进行数据交换
* 直接输入输出指令
    * 将外设的端口数据直接通过**AX**或者**AL**寄存器输入输出
    * [PORT]是外设的端口编号，为**一字节无符号数**
        * 只能取到00H～0FFH，即0～255
    * IN指令
        * 格式：
            * IN AL,[PORT]
                * AL<-(PORT)
            * IN AX,[PORT]
                * AX<-(PORT+1),(PORT)
    * OUT指令
        * 格式：
            * OUT [PORT],AL
                * (PORT)<-AL 
            * OUT [PORT],AX
                * (PORT+1),(PORT)<-AX
* 间接输入输出指令
    * 在外设和累加器进行数据传送前，先将端口地址放入DX寄存器
    * 适用于端口地址超出0～255的范围时
    * IN指令
        * 格式：
            * IN AL,DX
            * IN AX,DX 
    * OUT指令 
        * 格式：
            * OUT DX,AL 
            * OUT DX,AX 

---
## 程序直接控制IO方式
### CPU与IO之间的接口信息
一般有数据信息，控制信息和状态信息三种信息传递
### 工作过程
* 无条件传送方式
    * 适用于外设各种工作时间固定，且条件已知的场合下
* 程序查询传送方式
    * 适用于CPU与外设工作不同步的情况
    * 优点：
        * 可以用程序安排几个输入输出设备的优先顺序
        * 最先查询的设备其工作优先级也最高，修改查询次序实际上也是修改优先级
    * 缺点：
        * CPu需要不断执行IN指令查询工作状态，占用了大量CPU的时间
        * 尤其是外设的工作速度相对较慢，CPU与外设数据传输过程中CPU都需要等待

* 查询输入工作过程
    1. 从状态端口读入状态信息
    2. 测试Ready位
        * 若不为1则回到1，循环等待
        * 若为1则转到3
    3. 从数据端口读入数据到AX寄存器
* 查询输出工作过程
    1. 从状态端口读入状态信息
    2. 测试Busy位
        * 若为1则回到1，循环等待
        * 若为0则转到3
    3. 从缓冲区取数据输出