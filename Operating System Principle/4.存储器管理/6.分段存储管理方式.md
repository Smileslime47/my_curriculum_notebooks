[存储器管理](../操作系统原理.md)
# 分段存储管理方式
<!-- TOC -->

- [分段存储管理方式](#分段存储管理方式)
  - [引入原因](#引入原因)
  - [基本原理](#基本原理)
    - [分段](#分段)
    - [段表](#段表)
    - [地址变换机构](#地址变换机构)
    - [分段和分页的主要区别](#分段和分页的主要区别)
  - [信息共享](#信息共享)
  - [段页存储管理方式](#段页存储管理方式)
    - [基本原理](#基本原理-1)
    - [地址变换机构](#地址变换机构-1)

<!-- /TOC -->
---
## 引入原因
* 方便编程
    * 可直接使用段名和段内地址找到逻辑地址
* 信息共享
    * 程序和数据的共享是以信息的逻辑单位为基础的
    * 页没有任何逻辑意义，只是存放信息的物理单位
* 信息保护
    * 信息保护是以信息的逻辑单位为基础的
    * 同上
* 动态增长
    * 段在使用过程中数据量会不断变化，所需要的存储空间也会动态增加
    * 无法预先分配数据段的大小
* 动态链接
    * 当程序运行时，需要调用某个目标模块，才将该段调入内存中进行链接

---
## 基本原理
### 分段
分段地址的结构：
|31-----16|15-----0|
|----|----|
|段号|段内地址|

### 段表
每个分段分配一个**连续**的分区，但不一定需要相同大小  
进程中的各个段可以**离散**地装入内存中的不同分区

### 地址变换机构
**段表寄存器**：存放段表始址和段表长度  
进行地址变换时
1. 比较地址中的**段号**和段表长度
    * 段号>段表长度则访问越界，产生越界中断
    * 否则进入2
2. 根据段表的始址和地址的段号，计算出对应段表项位置
3. 从对应的段表项读出目标段的物理始址
4. 比较地址中的**段内地址**和段表长度
    * 段内地址>段表长度则访问越界，产生越界中断
    * 否则进入5
5. 将段始址于段内地址相加，得到要访问的内存物理地址

### 分段和分页的主要区别
* 页是信息的物理单位
* 页的大小固定并由系统决定
* 页的用户程序地址空间是一维的

---
## 信息共享
在分页管理系统中，数据存在不同页中，共享不同的信息需要共享多个页  
在分段管理系统中，共享信息仅需访问对应段即可

---
## 段页存储管理方式
### 基本原理
将用户程序分成若干个段，再把每个段分成若干个页  
地址由**段号、段内页号、页内地址**三部分组成

### 地址变换机构
同时配置有段表和页表
**段表**的内容为**页表**始址和页表长度

进行地址变换时
1. 比较段号和段表长判断是否越界
2. 求出该段对应段表项的位置
3. 通过对应段表项找到段对应页表始址
4. 通过段内页号找到页表中对应页的位置
5. 利用块号和页内地址得到物理地址