[进程管理](../操作系统原理.md)
# 进程同步
<!-- TOC -->

- [进程同步](#进程同步)
  - [同步](#同步)
  - [进程间关系](#进程间关系)
  - [同步规则](#同步规则)
    - [前提](#前提)
    - [解决](#解决)
  - [信号量机制](#信号量机制)
    - [整型信号量](#整型信号量)
    - [记录型信号量](#记录型信号量)
    - [AND型信号量](#and型信号量)
    - [一般信号量集](#一般信号量集)
  - [管程](#管程)
    - [组成](#组成)
    - [原则](#原则)
    - [条件变量（condition c）](#条件变量condition-c)

<!-- /TOC -->
---
## 同步
**互斥**：某一资源同时只允许一个访问者对其访问，具有唯一性和排他性  
**同步**：实现访问者对资源的有序访问（往往已经实现了互斥）  

**主要任务**：使并发进行的进程间能够有效地共享资源和相互合作  
**同步机制**：信号量机制和P、V操作  
**同步**和**互斥**共同协调进程间的制约关系

---
## 进程间关系
1. **直接关系**（相互合作）：发生在相关进程之间，有意识地要求另一伙伴进程提供消息，在未获得消息前处于等待状态
2. **间接关系**（资源共享）：不一定发生在相关进程间，无意识地竞争使用临界资源，资源每次只允许一个进程访问
   
**临界资源**（a.k.a.互斥资源/共享变量）：一次只允许一个进程使用  
**临界区**：涉及到临界资源的程序段

|互相感知程度|交互关系|对其他进程的影响|
|----|----|----|
|互相不感知|竞争关系|无影响|
|间接感知（使用共享资源）|通过共享进行协作|依赖于从其他进程获得的信息|
|直接感知（进程间直接通信）|通过通信进行协作|依赖于从其他进程获得的信息|

---
## 同步规则
* **空闲让进**：无进程在临界区时允许一个进程进入
* **忙则等待**：不允许两个以上进程同时进入临界区
* **有限等待**：进程的要求应当在有限时间内被满足
* **让权等待**：处于等待的进程应当放弃CPU

### 前提
* 任何进程无权停止其他进程
* 相对运行速度无硬性规定

### 解决
* 硬件同步：当进程进入临界区就屏蔽所有中断申请
  * 成本高
* 软件同步：利用程序判断空闲状态
  * 忙等待
* 信号量机制

---
## 信号量机制
**信号量**：多个进程通过单一信号量协作，进程在特定地方等待直至得到信号量

### 整型信号量
```
int s
wait(s)/p(s){
    s<=0则等待;
    s--;
}
signal(s)/v(s){
    s++;
}
```

### 记录型信号量
```
struct signal{
    int value;                  //资源量
    linkedList waitingProcess   //等待队列
}
wait(s){
    value--;                    //先"借走"一个资源，但因为实际上资源并不够所以先不使用
    value<=0则等待，将PCB置于队尾
}
signal(s){
    value++;
    value<=0则说明有进程借走了资源但处于等待
        唤醒waitingProcess表头
}
//只能给signal置一次初值
```
含义：
* v>0则说明有V个资源可用
* v=0则说明无资源可用
* v<0则说明无资源可用，但有|v|个资源等待资源中
* P、V操作必然成对出现
  * 互斥（锁/mutex）：出现在同一进程（加锁和释放必须由同一进程完成）
  * 同步：出现在不同进程（可以由一个进程释放，再由另一个进程得到）
* 同步P必然出现在互斥P之前，否则可能出现死锁状况

### AND型信号量
适用于同时申请**多种单个资源**，要么全部分配给它，要么一个都不分配
```
swait(s1,s2,...,sn){
  if(s1>=1&&s2>=1&&...&&sn>=1){
    for(s:s1,s2,...,sn)s--;
  }
  else{
    第一个不满足的sj.waitingProcess.add(this);
    this.block;
  }
}
ssignal(s1,s2,...,sn){
  for(s:s1,s2,...,sn){
    s++;
    readyQueue.add(s.waitingProcess.remove());
  }
}
```
AND型信号量不会触发死锁，但是效率较低

### 一般信号量集
进程同时申请**多种多个资源**，且资源剩余量存在**临界值**
```
swait(s1,d1,s2,d2,...,sn,dn){
  if(s1.value>=s1.min&&...&&sn.value>=sn.min){
    for(s:s1,...,sn)s.value-=d;
  }
  else
    第一个不满足的sj.waitingProcess.add(this);
    this.block;
    //当进程解除block时需要重新从s1开始全部判断
}
ssignal(s1,d1,s2,d2,...,sn,dn){
  for(s:s1,...,sn){
    s.value+=d;
    readyQueue.addAll(s.waitingProcess.removeAll());
  }
}
```
含义：
* min=demand：只有一个信号量，每次分配d个，少于则不分配
* min=demand=1
  * 互斥型信号量（value=1）
  * 记录型信号量（value>1）
* min=1;demand=0:可控开关
  * value>=1则允许进入临界区
  * value=0则禁止任何进程进入
  
缺点：
* 易读性差
* 不利于修改和维护
* 难以保证正确性
* 有可能导致死锁

---
## 管程
**管程**：关于共享资源的数据及对其操作的一组过程（类似对象的概念）

### 组成
* 局部于管程的共享变量
* 对数据结构操作的一组操作
* 初始化（constuctor）

### 原则
管程内管理**临界资源**，同时只能有一个进程访问  
当进入管程的进程（A进程）进入等待则释放互斥权，并导致B进程进入  
当A进程被唤醒时，管程中同时存在两个进程  
处理：
* P等待Q
* Q等待P
* 规定进程唤醒时自动退出管程

### 条件变量（condition c）
c.wait：进程在条件c上挂起，插入c的等待队列上，释放互斥权  
c.signal：在条件c上挂起的进程被唤醒