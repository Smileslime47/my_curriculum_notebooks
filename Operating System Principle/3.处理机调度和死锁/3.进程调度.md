[处理机调度和死锁](../操作系统原理.md)
# 进程调度
<!-- TOC -->

- [进程调度](#进程调度)
  - [调度](#调度)
    - [任务](#任务)
    - [组成](#组成)
    - [调度方式](#调度方式)
  - [轮转调度算法（RR）](#轮转调度算法rr)
    - [原理](#原理)
    - [切换时机](#切换时机)
    - [时间片大小的确定](#时间片大小的确定)
  - [优先级调度算法](#优先级调度算法)
    - [分类](#分类)
    - [静态优先级](#静态优先级)
    - [动态优先级](#动态优先级)
  - [多队列调度算法](#多队列调度算法)
    - [多级反馈队列调度算法](#多级反馈队列调度算法)
  - [基于公平的调度算法](#基于公平的调度算法)
    - [保证调度算法](#保证调度算法)
    - [公平分享调度算法](#公平分享调度算法)

<!-- /TOC -->
---
## 调度
### 任务
* 保存处理机现场信息
* 按照算法选取进程
* 把处理机分配给进程

### 组成
* 排队
* 分派
* 上下文切换

### 调度方式
* 非抢占方式
  * 不会抢占正在运行进程的处理机
  * 直至运行完成/进程阻塞才会分配给其他进程
* 抢占方式
  * 防止一个处理机被长时间独占
  * 用于实现人机交互

---
## 轮转调度算法（RR）
### 原理
所有就绪进程按照**FCFS**排成就绪队列  
系统每隔一段时间将产生一次中断，把CPU重新分配给队首，执行一个时间片

### 切换时机
* 若时间片未用完，程序完成运行
  * 激活调度程序，将其移出队列，调度新进程
* 若时间片已用完，程序未完成运行
  * 将其送至队列队尾

### 时间片大小的确定

---
## 优先级调度算法
### 分类
* 非抢占式调度
* 抢占式调度

### 静态优先级
优先级在运行时保持不变  
优先级依据：
* 进程类型
* 资源需求
* 用户需求

### 动态优先级
优先级随着**进程的推进/等待时间增加**而改变

---
## 多队列调度算法
设置多个就绪队列，将不同类型放在不同的队列  
队列根据具体情况使用不同的算法

### 多级反馈队列调度算法
* 使用多队列调度
    ```mermaid
        graph TB;
                就绪队列1-->就绪队列2;
                就绪队列1-->|S1|CPU;
                就绪队列2-->就绪队列3;
                就绪队列2-->|S2|CPU;
                就绪队列3-->就绪队列n;
                就绪队列3-->|S3|CPU;
                就绪队列n-->就绪队列n;
                就绪队列n-->|Sn|CPU;
    ```
  * 时间片：S1<S2<S3<...<Sn
  * 规定首个队列的算法略大于大部分进程需要
* 每个队列采用FCFS算法
  * 在一个时间片后若尚未完成，调度将其移入下一队列末尾
  * 在最后队列（n）则采用RR方式
* 按队列优先级调度
  * 当前面的队列全部空闲时才调度此队列运行

---
## 基于公平的调度算法
### 保证调度算法
当OS中有n个相同类型的进程时-->保证获得处理机的性能为1/n

算法：
1. 跟踪每个进程自创建以来**已经执行的处理时间**
2. 计算每个进程**应获得的处理时间**：自创建以来的时间除以n
3. 计算进程**获得处理时间的比率**：实际执行时间/应当执行时间
4. 比较各个进程的处理时间比率
5. 选择比率最小的进程分配给处理机，直至其比率超过其最近的对手进程

### 公平分享调度算法
分配给每个进程相同的处理时间  
但是对于拥有多个进程的用户而言不公平