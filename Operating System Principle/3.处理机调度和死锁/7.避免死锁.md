[处理机调度和死锁](../操作系统原理.md)
# 避免死锁
<!-- TOC -->

- [避免死锁](#避免死锁)
  - [安全状态](#安全状态)
  - [银行家算法](#银行家算法)
    - [数据结构](#数据结构)
    - [算法](#算法)
    - [安全性算法](#安全性算法)

<!-- /TOC -->
---
与预防不同，并非事先采取限制措施，而是在动态分配资源时，防止系统进入不安全状态

---
## 安全状态
存在一种进程顺序使得系统按照这个序列为每个进程分配所需资源  
直至最大需求，可以使每个进程顺序完成

---
## 银行家算法
设系统中有n个进程，m个种类的资源
### 数据结构
* 可利用资源向量 Availavle
  * 含有m个元素的数组，Available[j]=K表示有j类资源K个
* 最大需求矩阵 Max
  * n x m的矩阵，Max[i,j]=K表示进程i需要j类资源的最大数目为K个
* 分配矩阵 Allocation
  * n x m的矩阵，Allocatio[i,j]=K表示进程i已获得j类资源K个
* 需求矩阵Need
  * n x m的矩阵，Need[i,j]=K表示进程i还需要j类资源K个

上述矩阵满足关系：  
$Need[i,j]=Max[i,j]-Allocatio[i,j]$

### 算法
设$Request_i$是进程$P_i$对请求向量  
$Request_i[j]=k$指进程$P_i$申请了k个j类型的资源

1. $Request_i[j]\leq Need[i,j]$
   * 是则跳到步骤2
   * 否则抛出异常（他需要的资源已超过最大值）
2. $Request_i[j]\leq Available[i,j]$
   * 是则跳到步骤3
   * 否则资源不足，$P_i$进程等待
3. 执行操作：
   * $Available[j]-=Request_i[j]$
   * $Allocation[i,j]+=Request_i[j]$
   * $Need[i,j]-=Request_i[j]$
   * 跳到步骤4
4. 执行安全性算法，判断执行3后系统是否处于安全状态
   * 是则分配资源
   * 否则操作回退，$P_i$进程等待

### 安全性算法
1. 初始化
  * Work工作向量，表示系统当前所剩各类资源数目。
    * 初始时$Work=Available$
  * Finish，表示系统是否有足够资源分配给进程使之完成运行。
    * 初始时$Finish[i]=false$
2. 找到一个进程满足条件
   * $Finish[i]=false$
   * $Need[i,j]\leq Work[j]$
3. 进程$P_i$可以获得资源并独立运行至结束，随后释放它占有的资源，故执行操作
   * $Work[j]+=Allocation[i,j]$
   * $Finish[i]=true$
   * 回到步骤2
4. 若最终所有进程均满足$Finish[i]=true$则系统处于安全状态