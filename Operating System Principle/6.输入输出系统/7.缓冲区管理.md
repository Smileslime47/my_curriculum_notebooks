[输入输出系统](../操作系统原理.md)
# 缓冲区管理
<!-- TOC -->

- [缓冲区管理](#缓冲区管理)
  - [引入原因](#引入原因)
  - [单/双缓冲区](#单双缓冲区)
    - [单缓冲区](#单缓冲区)
    - [双缓冲区](#双缓冲区)
  - [环形缓冲区](#环形缓冲区)
    - [组成](#组成)
    - [使用](#使用)
    - [同步问题](#同步问题)
  - [缓冲池](#缓冲池)
    - [组成](#组成-1)
    - [过程](#过程)
    - [工作方式](#工作方式)

<!-- /TOC -->
---
## 引入原因
* 缓和CPU与IO设备速度不匹配
* 减少对CPU的中断频率，放宽对CPU中断响应的限制
* 解决数据粒度（数据单元大小）不匹配的问题
* 提高CPU和IO设备的并行性

---
## 单/双缓冲区
### 单缓冲区
每当用户进程发出IO请求时，操作系统就在主存中为之分配一个缓冲区

### 双缓冲区
**单缓冲区问题**：使用缓冲区时互斥，效率低下，任意时刻只能单方向数据传输

在两台设备中设置两组缓冲区，一组用作发送缓冲区，一组用作接受缓冲区

---
## 环形缓冲区
### 组成
由多个缓冲区组成，每个缓冲区大小相同

可分为三种类型：
* 用于装入输入数据的空缓冲区R
* 已装满数据的缓冲区G
* 计算进程正在使用的现行工作缓冲区C

![]()

### 使用
* GetBuf过程
* ReleaseBuf过程

### 同步问题
使用输入循环缓冲，可使输入进程和计算进程并行进行。

相应地，指针Nexti和指针Nextg不断沿着顺时针方向移动，可能出现：
* Nexti指针追赶上Nextg指针
    * 输入进程输入数据的速度大于计算进程处理数据的速度
* Nextg指针追赶上Nexti指针
    * 计算进程处理数据的速度大于输入进程输入数据的速度

---
## 缓冲池
### 组成
缓冲池管理着多个缓冲区  
每个缓冲区的组成：
* 用于标识和管理的缓冲首部
* 用于存放数据的缓冲体

缓冲首部的组成：
* 缓冲区号
* 设备号
* 设备上的数据块号
* 同步信号量
* 队列链接指针

一般将缓冲池中具有相同类型的缓冲区组成一个队列
* 空白缓冲队列emq
* 输入队列inq
* 输出队列outq

### 过程
* addBuf(type,number)过程
    * 用于将参数number所指示的缓冲区B挂在type队列上
* takeBuf(type)过程
    * 用于从type队列所指示的队首拿出一个缓冲区

### 工作方式
* 收容输入
    * getBuf(emq)
    * putBuf(inq,hin)
* 提取输入
    * getBuf(inq)
    * putBuf(emq,sin)
* 收容输出
    * getBuf(emq)
    * putBuf(outq,hout)
* 提取输出
    * getBuf(outq)
    * putBuf(emq,sout)

![]()