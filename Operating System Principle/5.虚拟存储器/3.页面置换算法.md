[虚拟存储器](../操作系统原理.md)
# 页面置换算法
<!-- TOC -->

- [页面置换算法](#页面置换算法)
  - [算法](#算法)
    - [最佳置换算法](#最佳置换算法)
    - [先进先出置换算法](#先进先出置换算法)
    - [最近最久未使用算法（LRU）](#最近最久未使用算法lru)
    - [最少使用置换算法（LFU）](#最少使用置换算法lfu)
  - [Clock置换算法](#clock置换算法)
    - [简单的Clock算法](#简单的clock算法)
    - [改进型Clock算法](#改进型clock算法)
  - [页面缓冲算法（Page Buffering Algorithm a.k.a. PBA）](#页面缓冲算法page-buffering-algorithm-aka-pba)
    - [影响置换的因素](#影响置换的因素)
    - [算法](#算法-1)
  - [访问内存的有效时间](#访问内存的有效时间)

<!-- /TOC -->
---
## 算法
### 最佳置换算法
所选择的被淘汰页面在以后都不再被使用，或许是在最长时间内都不再会被访问的页面

### 先进先出置换算法
选择在内存中驻留时间最久的页面淘汰

但与实际运行规律不符，如在进程中有些经常被访问的页面，含有全局变量等

### 最近最久未使用算法（LRU）

* 硬件支持：
    * 每个内存中的页面配置一个移位寄存器
        * 访问某个页面时将其寄存器最高位置1
        * 每隔一段时间将寄存器右移一位
        * 寄存器数值最小的页面即为最近最久未使用页面
    * 栈

### 最少使用置换算法（LFU）
* 每个内存中的页面配置一个移位寄存器  
    * 访问某个页面时将其寄存器最高位置1  
    * 每隔一段时间将寄存器右移一位  
    * 寄存器各位数字之和最小的页面即为最少使用页面

---
## Clock置换算法
### 简单的Clock算法
又称最近未使用算法（NRU）  
近似LRU算法，但不需要较多硬件支持  
* 为每个页面设置一位访问位
* 将内存中所有页面通过指针链接成一个循环队列  
* 通过指针遍历队列
    * 若访问位为0则置换该页面然后访问位置1
    * 否则将访问位 置0，然后检查下一页

缺陷：对于内存中没有修改过的页面，虽然没有必要但置换时再次写回磁盘，置换代价大

### 改进型Clock算法
* 为每个页面设置访问位A和修改位M
    * AM=00时，既未被访问也未被修改，是最佳淘汰页
    * AM=01时，最近未被访问但曾经被修改过，是次佳淘汰页
    * AM=10时，最近已被访问但没有被修改，可能被再次访问
    * AM=11时，最近已被访问且曾经被修改，可能被再次访问
* 步骤
    1. 第一轮扫描寻找满足AM=00的第一个页面，扫描期间对A和M不进行修改
    2. 第二轮扫描寻找满足AM=01的第一个页面，将此前所有被扫描过的页面A均置0
    3. 若仍未找到淘汰页，而此时已将所有访问位A均置0，回到第一步重新扫描，一定能找到淘汰页

---
## 页面缓冲算法（Page Buffering Algorithm a.k.a. PBA）
### 影响置换的因素
* 页面置换算法
* 写回磁盘的频率
* 读入内存的频率

### 算法
在内存中设置两个链表
* 空闲页面链表
    * 空闲物理块链表，用于分配给频繁缺页的进程，降低该进程缺页率
    * 当一个未被修改的页被换出时不写回磁盘，而是放在空闲链表的链尾
    * 没有被修改的页没必要重新写回磁盘，分配给新进程时新页可以直接覆盖写入此页
* 修改页面链表
    * 由已修改页面形成的链表，减少已修改页面换出的次数

---
## 访问内存的有效时间
请求分页管理方式中，内存有效访问时间（EAT）不仅要考虑访问页表和物理地址的时间，还要考虑**缺页中断**的处理时间
* λ为查找快表时间，t为查找内存时间，ε为中断处理时间
    * 被访问页在内存，对应页表项在快表
        * EAT=λ+t
    * 被访问页在内存，对应页表项不在块表
        * EAT=2*(λ+t)
    * 被访问页不在内存
        * EAT=2*(λ+t)+ε
    * 考虑到快表命中率和缺页情况，设a为命中率，f为缺页率
        * EAT=λ+a*t+(1-a)*[t+f*(ε+λ+t)+(1-f)*(λ+t)]

